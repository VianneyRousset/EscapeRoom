#!/usr/bin/env python

from os.path import abspath, join, pardir, isdir, isfile, dirname, basename
from os import listdir
import ast

HEADER_TEXT = '''\
{0} This file has been autogenerated by configure.py please modify 'config'
{0} files and run configure.py instead of modifying this file.'''

CONFIG_FILENAME = 'config'

class Config(dict):

    def __init__(self, path):
        with open(path) as f:
            d = ast.literal_eval('{'+f.read()+'}') #TODO use safer config (but json hasn't hex nb) 
            super().__init__(d)


class Container(dict):


    def __init__(self, path, directexclude=set(), **kwargs):
        self.path = path
        self.codes = dict()
        self.kwargs = kwargs
        exclude = kwargs.get('exclude', set()).union(directexclude)
        self.counter = countExcluding(kwargs.get('start', 0x01), exclude) 

    def add(self, a):
        a.code = next(self.counter)
        self.update({a.name:a})
        self.codes.update({a.code:a.name})

    def writeCodes(self, f, ndigits=1, end='\n'):
        for m in self.values():
            m.write_define(f, ndigits=ndigits)
        if end: f.write(end)

    def get(self, k, d=None):
        if isinstance(k, str): return super().get(k, d)
        return super().get(self.codes.get(k, None), d)

    def __getitem__(self, k):
        if isinstance(k, str): return super().__getitem__(k)
        return super()[self.codes[k]]

    def getcodes(self):
        return self.codes

    def getcontent(self):
        return {'codes': self.getcodes(), 'content': {k:v.getcontent() for k,v in super().items()}}


class ContainerFolder(Container):

    def __init__(self, path, contenttype, directexclude=set(), **kwargs):
        super().__init__(path, directexclude, **kwargs)
        self.contenttype = contenttype
        self.loadFolder()

    def loadFolder(self, relativepath='.'):
        absp = lambda x: join(self.path, relativepath, x)
        cond = lambda x: isdir(absp(x)) and isfile(join(absp(x), CONFIG_FILENAME))
        for p in filter(cond, listdir(absp('.'))):
            self.add(self.contenttype(absp(p), code=next(self.counter)))


class ContainerFile(Container):

    def __init__(self, path, directexclude=set(), **kwargs):
        super().__init__(path, directexclude, **kwargs)
        self.loadConfigFile()

    def loadConfigFile(self, relativepath='.'):
        self.parseConfig(Config(join(self.path, relativepath, CONFIG_FILENAME)))

    def parseConfig(self, cfg):
        ''' should be overwritten '''
        pass


class LibraryContainer(ContainerFolder):

    def __init__(self, path, **kwargs):
        super().__init__(path, Library, directexclude=kwargs.get('elib', set()), **kwargs)


class RoomContainer(ContainerFolder):

    def __init__(self, path, **kwargs): 
        super().__init__(path, Room, directexclude=kwargs.get('eroom', set()), **kwargs)


class DeviceContainer(ContainerFolder):

    def __init__(self, path, **kwargs):
        super().__init__(path, Device, directexclude=kwargs.get('edev', set()), **kwargs)


class LogmsgContainer(ContainerFile):

    def __init__(self, path, **kwargs):
        super().__init__(path, directexclude=kwargs.get('elogmsg', set()), **kwargs)

    def parseConfig(self, cfg):
        logmsg = cfg.get('logmsg', dict())
        for level in {'error', 'warn', 'info', 'debug'}:
            for n,x in logmsg.get(level, dict()).items():
                name = f'{level}_{n}'
                description = x if isinstance(x, str) else x[0]
                description_params = [] if isinstance(x, str) else x[1]
                self.add(Logmsg(name, None, level, description, description_params, **self.kwargs))


class CommandContainer(ContainerFile):

    def __init__(self, path, **kwargs):
        super().__init__(path, directexclude=kwargs.get('ecmd', set()), **kwargs)

    def parseConfig(self, cfg):
        commands = cfg.get('commands', dict())
        for n in commands:
            self.add(Command(name=f'cmd_{n}', code=None))


class ComponentContainer(ContainerFile):

    def __init__(self, path, **kwargs):
        super().__init__(path, directexclude=kwargs.get('ecomp', set()), **kwargs)

    def parseConfig(self, cfg):
        components = cfg.get('components', dict())
        for n,v in components.items():
            self.add(Component(name=n, code=None, value=v, **self.kwargs))


class Element:

    def __init__(self, name, code=None):
        self.name = name
        self.code = code

    def getcontent(self):
        ''' should be overwritten '''
        pass

    def write_define(self, f, ndigits=2):
        write_defineInt(f, self.name, self.code, ndigits=ndigits)


# An element is a folder containing a config file
class FolderElement(Element):

    def __init__(self, path, code=None):
        self.path = path
        self.cfg = Config(join(path, CONFIG_FILENAME))
        super().__init__(name=basename(path), code=code)


class System(FolderElement):

    ROOMS_DIR  = 'rooms'
    LIBS_DIR   = 'libs'

    def __init__(self, path, **kwargs):
        super().__init__(path)
        self.protocol = self.cfg.get('protocol', **kwargs)
        kwargs['exclude'] = kwargs.get('exclude', set()).union({*self.getDelimitersInt()})
        self.commands = CommandContainer(self.path, **kwargs)
        self.libraries = LibraryContainer(join(self.path, 'libs'), **kwargs)
        kwargs['elogmsg'] = kwargs.get('elogmsg', set()).union(self.libraries.getcodes().keys())
        self.rooms = RoomContainer(join(self.path, 'rooms'), **kwargs)

    def getDelimitersInt(self):
        c = self.protocol['packet_delimiters']
        if isinstance(c, str): c = c.encode('ascii')
        return [*c]

    def getcontent(self):
        libraries = {l.name: l.getcontent() for l in self.libraries.values()}
        rooms = {r.name: r.getcontent() for r in self.rooms.values()}
        return {'commands': self.commands.getcontent(), 'libraries': self.libraries.getcontent(),
                'rooms': self.rooms.getcontent(), 'protocol': self.protocol}


class Library(FolderElement):

    def __init__(self, path, code, **kwargs):
        super().__init__(path)
        self.logmsg = LogmsgContainer(self.path, **kwargs)

    def getcontent(self):
        return {'logmsg': self.logmsg.getcontent()}


class Room(FolderElement):

    def __init__(self, path, code, **kwargs):
        super().__init__(path)
        self.description = self.cfg.get('description', None)
        self.devices = DeviceContainer(join(self.path, 'devices'), **kwargs)

    def getcontent(self):
        return {'description': self.description, 'devices': self.devices.getcontent()}


class Device(FolderElement):

    #TODO extend to have room cmd
    def __init__(self, path, code, **kwargs):
        super().__init__(path)
        self.components = ComponentContainer(self.path, **kwargs) 
        self.logmsg = LogmsgContainer(self.path, **kwargs)
        self.code = code
    
    def getcontent(self):
        return {'components': self.components.getcontent(), 'logmsg': self.logmsg.getcontent()}


class Logmsg(Element):

    def __init__(self, name, code, level, description, description_params):
        super().__init__(name, code)
        self.level = level 
        self.description = description
        self.description_params = description_params

    def getcontent(self):
        return {'code': self.code, 'name': self.name, 'description': self.description,
                'description_params': self.description_params}


class Command(Element):

    def __init__(self, name, code):
        super().__init__(name, code)

    def getcontent(self):
        return {'name': self.name, 'code': self.code}


class Component(Element):

    def __init__(self, name, code, value):
        super().__init__(name, code)
        self.value = value

    def getcontent(self):
        return {'name': self.name, 'code': self.code, 'value': self.value}


def countExcluding(start=0, exclude=set()):
    i = start
    while True:
        while i in exclude:
            i += 1
        yield i
        i += 1

def writeHeader(f, mode, end='\n\n'):
    f.write(HEADER_TEXT.format({'C': '//', 'python': '#'}[mode]))
    if end: f.write(end)

def writeFooter(f, mode, end='\n'):
    f.write({'C': '#endif', 'python': ''}[mode] + '\n')
    if end: f.write(end)

def writePragmaOnce(f, filename, end='\n'):
    m = filename.replace('.', '_').upper() + '_'
    f.write(f'#ifndef {m}\n')
    f.write(f'#define {m}\n')
    if end: f.write(end)

def write_define(f, name, value, end='\n'):
    f.write('#define {:56s} {}'.format(name.upper(), value))
    if end: f.write(end)

def write_defineInt(f, name, value, ndigits=None, base=16, end='\n'):
    prefix = {2:'0b', 10:'', 16:'0x'}[base]
    base = {2:'b', 10:'d', 16:'x'}[base]
    n = '' if ndigits == None else f'0{ndigits}'
    value = (prefix + '{:' + n + base + '}').format(value)
    write_define(f, name=name, value=value, end=end)

def write_defineChar(f, name, c):
    if isinstance(c, bytes): c = repr(c.decode('ascii'))
    elif isinstance(c, str): c = repr(c)
    elif isinstance(c, int): c = repr(bytes([c]).decode('ascii'))
    write_define(f, name, c)

def write_typedef(f, name, t, end='\n'):
    if 'int' in t: t += '_t'
    f.write(f'typedef {t} {name.capitalize()}_t;')
    if end: f.write(end)

def write_comment(f, s):
    comment = pformat(f'// {s}')
    if '\n' in comment:
        comment = pformat(f'/* {s} */')
    f.write(comment)

