#!/usr/bin/env python

from sys import argv, stderr, exit
from os import listdir
from os.path import isdir 
from itertools import chain
import json

#TODO all codes/addresses should be auto-generated and not set manually
#TODO first convert all hex value to int in data dict
#TODO gen a nice-looking table with cmd, components, status... for each devices

HEADER_TEXT ='''\
// This file has been autogenerated by configure.py please modify config_*.py
// files and run configure.py instead of modifying this file.'''

DEVDIR = 'devices'
TEMPLATES_DIR = 'autogeneratedFileTemplates'

def printerr(msg):
    print(f'{msg} -> exit', file=stderr)
    exit(1)

def control_data_consistency(data):
    print('Checking data consistency')

    # check all sections
    print('-> checking sections')
    _sections = {'computer', 'devices', 'communication'}
    for t in _sections:
        if t not in data:
            printerr(f'!! missing section "{t}"')
            return False
    for t in data:
        if t not in _sections:
            print(f'$$ useless extra section {t}')

    computer = data['computer']
    devices = data['devices']
    communication = data['communication']

    # check computer
    print('-> checking computer')
    _fields = {'address'}
    for f in _fields:
        if f not in computer: 
            printerr('!! missing missing field "{f}" in "computer"')
    for f in computer:
        if f not in _fields:
            print(f'$$ useless extra field {f} in "computer"')

    # check devices
    print('-> checking devices')
    if len(devices) == 0:
        print('$$ empty dict: "devices"')

    _fields = {'address', 'i2c_address', 'components'}
    for n,d in devices.items():
        for f in _fields:
            if f not in d:
                printerr(f'!! missing field "{f}" in device "{n}"')
        for f in d:
            if f not in _fields:
                print(f'$$ seless extra field {f} in device "{n}"')

    
    # check devices directory
    print('-> checking devices directory')
    if not isdir(DEVDIR):
        printerr('Missing arduinos directory')

    directories = list(filter(lambda f: isdir(f'{DEVDIR}/{f}'), listdir(DEVDIR)))
    for d in devices:
        if d not in directories:
            printerr(f'!! missing devices folder "{d}"')

    # check addresses unicity
    print('-> checking addresses unicity')
    allAddresses = []
    for d in chain([computer], devices.values()):
        a = d['address']
        allAddresses += [int(a, base=0) if isinstance(a, str) else a]
        if len(allAddresses) > len(set(allAddresses)):
            printerr(f'!! duplicated address: {sorted(allAddresses)}')

    # check I2C addresses unicity
    print('-> checking I2C addresses unicity')
    allAddresses = []
    for d in devices.values():
        a = d['i2c_address']
        allAddresses += [int(a, base=0) if isinstance(a, str) else a]
        if len(allAddresses) > len(set(allAddresses)):
            printerr(f'!! duplicated I2C address: {sorted(allAddresses)}')

#    # check communication 
#    print('-> checking communication')
#    _fields = {'commands', 'return_codes', 'packet_terminator', 'UART', 'I2C'}
#    for f in _fields:
#        if f not in communication: 
#            printerr(f'!! missing missing field "{f}" in "communication"')
#    for f in communication:
#        if f not in _fields:
#            print(f'$$ useless extra field {f} in "communication"')
#
#    if len(communication['commands']) == 0:
#        print('$$ empty dict: "commands"')
#
#    if len(communication['return_codes']) == 0:
#        print('$$ empty dict: "return_codes"')
#
#    # check commands codes unicity 
#    print('-> checking commands code unicity')
#    allCodes = []
#    for cmd in communication['commands'].values():
#        code = cmd['code']
#        allCodes += [int(code, base=0) if isinstance(code, str) else code]
#        if len(allCodes) > len(set(allCodes)):
#            printerr(f'!! duplicated cmd_code: {sorted(allCodes)}')
#
#    # check return_codes unicity 
#    print('-> checking return_codes unicity')
#    allCodes = []
#    for code in communication['return_codes'].values():
#        allCodes += [int(code, base=0) if isinstance(code, str) else code]
#        if len(allCodes) > len(set(allCodes)):
#            printerr(f'!! duplicated return_codes: {sorted(allCodes)}')

    # check packet_terminator
    print('-> checking packet_terminator')
    pt = communication['packet_terminator']
    if len(pt) > 1:
        printerr(f'packet_terminator has to be a single character (got: {repr(pt)})')

    # checking timeouts
    print('-> checking timeouts')
    for p in ['UART', 'I2C']:
        t = communication[p]['timeout'] 
        if t > 10:
            print(f'$$ {p} timeout seems to long (got {t} seconds)')
        if t < 1e-3:
            printerr(f'Invalid {p} timeout: {t} secondes (need to be > 1ms)')

    # checking baudrates 
    print('-> checking baudrates')
    for p in ['UART', 'I2C']:
        t = communication[p]['baudrate'] 
        if t > 100e3 or t < 100:
            print(f'$$ absurd {p} baudrates: {t} Hz')


def configure_devices(data):
    devices = data['devices']
    communication = data['communication']
    print(f'Configuring devices')

    # devices/*/address.hpp header files
    enum = [('COMPUTER', data['computer']['address'])]
    enum = enum + [(d.upper(),a['address']) for d,a in devices.items()]
    enum = [(d, int(a, base=0) if isinstance(a, str) else a) for d,a in enum]
    enum = ['\tCOM_ADDRESS_{:s} = 0x{:02x}'.format(d,a) for d,a in enum] 
    enum = ',\n'.join(enum)

    pt = communication['packet_terminator']
    if pt == '"':
        pt = r'\"'
    else:
        pt = repr(pt)

    # header
    i2cAddresses = ['   0']*0x80
    for d in devices.values():
        a = d['address']
        a = int(a, base=0) if isinstance(a, str) else a
        i2c_a = d['i2c_address']
        i2c_a = int(i2c_a, base=0) if isinstance(i2c_a, str) else i2c_a
        i2cAddresses[a] = '0x{:02x}'.format(i2c_a)

    def grouper(iterable, n):
        args = [iter(iterable)] * n
        return zip(*args)

    i2cTable = '\t'+',\n\t'.join(', '.join(i) for i in grouper(i2cAddresses, 8))

    for d in data['devices']:
        template = open(f'{TEMPLATES_DIR}/address.hpp').read()

        fpath = f'{DEVDIR}/{d}/address.hpp' 
        with open(fpath, 'w') as f:
            print(f'Writing {fpath}')
            f.write(template.format(header=HEADER_TEXT,
                                    addressEnum=enum,
                                    packetTerminator=pt,
                                    uartBaudrate=communication['UART']['baudrate'],
                                    uartTimeout=round(communication['UART']['timeout']*1000),
                                    i2cBaudrate=communication['I2C']['baudrate'],
                                    i2cTimeout=round(communication['I2C']['timeout']*1000),
                                    i2cAddressesN=len(i2cAddresses),
                                    i2cTable=i2cTable,
                                    footer=''))

    # devices/*/device.hpp header files
    commands = data['communication']['commands']
    cmd = [(n.upper(), c['code']) for n,c in commands.items()]
    cmd = [(n, int(c, base=0) if isinstance(c, str) else c) for n,c in cmd]
    cmd = '\t' + ',\n\t'.join('CMD_{} = 0x{:02x}'.format(n, c) for n,c in cmd) 

    commands = data['communication']['return_codes']
    rtn = [(n.upper(), c) for n,c in commands.items()]
    rtn = [(n, int(c, base=0) if isinstance(c, str) else c) for n,c in rtn]
    rtn = '\t' + ',\n\t'.join('RTN_{} = 0x{:02x}'.format(n, c) for n,c in rtn) 

    for dname, d in data['devices'].items():
        template = open(f'{TEMPLATES_DIR}/device.hpp').read()
        comp = [(key.upper(), c['code']) for key,c in d['components'].items()]
        comp = [(key, int(c, base=0) if isinstance(c, str) else c) for key,c in comp]
        comp = '\t' + ',\n\t'.join('COMP_{} = 0x{:02x}'.format(key, c) for key,c in comp) 

        fpath = f'{DEVDIR}/{dname}/device.hpp' 
        with open(fpath, 'w') as f:
            print(f'Writing {fpath}')
            f.write(template.format(header=HEADER_TEXT,
                                    name=dname,
                                    address=d['address'],
                                    components=comp,
                                    commands=cmd,
                                    returnCodes=rtn,
                                    footer=''))




if __name__ == '__main__':

    if len(argv) < 2:
        printerr(f'Usage: {argv[0]} configuration.room')

    def object_pairs_hook(data):
        dataD = dict(data)
        if len(data) > len(dataD):
            printerr(f'Multiple definition in {[k[0] for k in data]}')
        return dict(data)

    data = json.load(open(argv[1]), object_pairs_hook=object_pairs_hook)

    control_data_consistency(data)
    configure_devices(data)

